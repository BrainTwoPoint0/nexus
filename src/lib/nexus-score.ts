import { createClient } from '@/lib/supabaseClient';

export interface NexusScoreFactors {
  skills_score: number;
  experience_score: number;
  sector_score: number;
  location_score: number;
  availability_score: number;
  remote_work_score: number;
}

export interface NexusScoreResult extends NexusScoreFactors {
  overall_score: number;
  explanation: string;
}

interface Candidate {
  skills?: string[];
  experience_years?: number;
  sector_preferences?: string[];
  location?: string;
  time_commitment_preference?: string;
  travel_willingness?: string;
  remote_work_preference?: string;
  availability_start_date?: string;
}

interface Job {
  required_skills?: string[];
  experience_required?: number;
  sector?: string;
  location?: string;
  remote_work_allowed?: boolean;
  travel_required?: string; // 'none', 'domestic', 'international', 'extensive'
}

export async function calculateNexusScore(
  candidateId: string,
  jobId: string
): Promise<NexusScoreResult> {
  const supabase = createClient();

  // Fetch candidate data
  const { data: candidate, error: candidateError } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', candidateId)
    .single();

  if (candidateError) {
    throw new Error(`Failed to fetch candidate: ${candidateError.message}`);
  }

  // Fetch job data
  const { data: job, error: jobError } = await supabase
    .from('jobs')
    .select('*')
    .eq('id', jobId)
    .single();

  if (jobError) {
    throw new Error(`Failed to fetch job: ${jobError.message}`);
  }

  // Calculate individual scores
  const skills_score = calculateSkillsMatch(candidate, job);
  const experience_score = calculateExperienceMatch(candidate, job);
  const sector_score = calculateSectorMatch(candidate, job);
  const location_score = calculateLocationMatch(candidate, job);
  const availability_score = calculateAvailabilityMatch(candidate, job);
  const remote_work_score = calculateRemoteWorkMatch(candidate, job);

  // Calculate weighted overall score with updated weights
  const overall_score = Math.round(
    skills_score * 0.35 +
      experience_score * 0.25 +
      sector_score * 0.18 +
      location_score * 0.08 +
      availability_score * 0.09 +
      remote_work_score * 0.05
  );

  const explanation = generateScoreExplanation({
    skills_score,
    experience_score,
    sector_score,
    location_score,
    availability_score,
    remote_work_score,
    overall_score,
    explanation: '', // Will be generated by the function
  });

  // Store the score in the database
  await supabase.from('nexus_scores').upsert({
    candidate_id: candidateId,
    job_id: jobId,
    overall_score,
    skills_score,
    experience_score,
    sector_score,
    location_score,
    availability_score,
    remote_work_score,
    calculated_at: new Date().toISOString(),
  });

  return {
    overall_score,
    skills_score,
    experience_score,
    sector_score,
    location_score,
    availability_score,
    remote_work_score,
    explanation,
  };
}

function calculateSkillsMatch(candidate: Candidate, job: Job): number {
  if (!candidate.skills || !job.required_skills) return 0;

  const candidateSkills = candidate.skills.map((s: string) => s.toLowerCase());
  const requiredSkills = job.required_skills.map((s: string) =>
    s.toLowerCase()
  );

  if (requiredSkills.length === 0) return 50; // Neutral score if no requirements

  const matchedSkills = requiredSkills.filter((skill: string) =>
    candidateSkills.some(
      (cSkill: string) => cSkill.includes(skill) || skill.includes(cSkill)
    )
  );

  const matchPercentage = (matchedSkills.length / requiredSkills.length) * 100;
  return Math.min(100, Math.round(matchPercentage));
}

function calculateExperienceMatch(candidate: Candidate, job: Job): number {
  if (!candidate.experience_years || !job.experience_required) return 50;

  const candidateExp = candidate.experience_years;
  const requiredExp = job.experience_required;

  if (candidateExp >= requiredExp) {
    // Bonus for more experience, but diminishing returns
    const bonus = Math.min(20, (candidateExp - requiredExp) * 2);
    return Math.min(100, 80 + bonus);
  } else {
    // Penalty for less experience
    const ratio = candidateExp / requiredExp;
    return Math.max(0, Math.round(ratio * 80));
  }
}

function calculateSectorMatch(candidate: Candidate, job: Job): number {
  if (!candidate.sector_preferences || !job.sector) return 50;

  const candidatePreferences = candidate.sector_preferences.map((s: string) =>
    s.toLowerCase()
  );
  const jobSector = job.sector.toLowerCase();

  const isMatch = candidatePreferences.some(
    (pref: string) => pref.includes(jobSector) || jobSector.includes(pref)
  );

  return isMatch ? 100 : 30; // Strong match or low score
}

function calculateLocationMatch(candidate: Candidate, job: Job): number {
  if (!candidate.location || !job.location) return 50;

  const candidateLocation = candidate.location.toLowerCase();
  const jobLocation = job.location.toLowerCase();

  // Check for remote work
  if (jobLocation.includes('remote') || jobLocation.includes('anywhere')) {
    return 100;
  }

  // Check for city/country match
  if (
    candidateLocation.includes(jobLocation) ||
    jobLocation.includes(candidateLocation)
  ) {
    return 100;
  }

  // Check for same country (basic implementation)
  const candidateCountry = candidateLocation.split(',').pop()?.trim();
  const jobCountry = jobLocation.split(',').pop()?.trim();

  if (candidateCountry === jobCountry) {
    return 70;
  }

  return 30; // Different countries
}

function generateScoreExplanation(scores: NexusScoreResult): string {
  const factors = [];

  if (scores.skills_score >= 80) {
    factors.push('Excellent skills match');
  } else if (scores.skills_score >= 60) {
    factors.push('Good skills alignment');
  } else if (scores.skills_score >= 40) {
    factors.push('Some relevant skills');
  } else {
    factors.push('Limited skills match');
  }

  if (scores.experience_score >= 80) {
    factors.push('Strong experience fit');
  } else if (scores.experience_score >= 60) {
    factors.push('Adequate experience');
  } else {
    factors.push('Experience gap identified');
  }

  if (scores.sector_score >= 80) {
    factors.push('Perfect sector match');
  } else if (scores.sector_score >= 60) {
    factors.push('Related sector experience');
  } else {
    factors.push('Different sector background');
  }

  if (scores.location_score >= 80) {
    factors.push('Location compatible');
  } else if (scores.location_score >= 60) {
    factors.push('Regional match');
  } else {
    factors.push('Location may be a factor');
  }

  if (scores.availability_score >= 80) {
    factors.push('Excellent availability match');
  } else if (scores.availability_score >= 60) {
    factors.push('Good availability alignment');
  } else if (scores.availability_score >= 40) {
    factors.push('Adequate availability');
  } else {
    factors.push('Availability concerns');
  }

  if (scores.remote_work_score >= 80) {
    factors.push('Perfect remote work fit');
  } else if (scores.remote_work_score >= 60) {
    factors.push('Good remote work match');
  } else if (scores.remote_work_score >= 40) {
    factors.push('Acceptable work arrangement');
  } else {
    factors.push('Work arrangement mismatch');
  }

  return factors.join(' â€¢ ');
}

export async function getNexusScoreForCandidate(
  candidateId: string,
  jobId: string
): Promise<NexusScoreResult | null> {
  const supabase = createClient();

  const { data, error } = await supabase
    .from('nexus_scores')
    .select('*')
    .eq('candidate_id', candidateId)
    .eq('job_id', jobId)
    .single();

  if (error || !data) {
    return null;
  }

  return {
    overall_score: data.overall_score,
    skills_score: data.skills_score,
    experience_score: data.experience_score,
    sector_score: data.sector_score,
    location_score: data.location_score,
    availability_score: data.availability_score || 50,
    remote_work_score: data.remote_work_score || 50,
    explanation: generateScoreExplanation(data),
  };
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
function calculateAvailabilityMatch(candidate: Candidate, job: Job): number {
  // If no availability data, return neutral score
  if (
    !candidate.availability_start_date &&
    !candidate.time_commitment_preference
  ) {
    return 50;
  }

  let score = 50;

  // Check availability start date (if candidate has one)
  if (candidate.availability_start_date) {
    const startDate = new Date(candidate.availability_start_date);
    const today = new Date();
    const daysUntilAvailable = Math.ceil(
      (startDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (daysUntilAvailable <= 0) {
      score += 30; // Available immediately
    } else if (daysUntilAvailable <= 30) {
      score += 20; // Available within a month
    } else if (daysUntilAvailable <= 90) {
      score += 10; // Available within 3 months
    } else {
      score -= 10; // Available later than 3 months
    }
  } else {
    score += 25; // No specific start date means available immediately
  }

  // Check time commitment preference
  if (candidate.time_commitment_preference) {
    // For now, assume all jobs prefer full-time or part-time commitment
    // This can be enhanced when job preferences are added
    switch (candidate.time_commitment_preference) {
      case 'full-time':
        score += 25;
        break;
      case 'part-time':
        score += 20;
        break;
      case 'project-based':
        score += 15;
        break;
      case 'consulting':
        score += 10;
        break;
      default:
        score += 0;
    }
  }

  return Math.min(100, Math.max(0, score));
}

function calculateRemoteWorkMatch(candidate: Candidate, job: Job): number {
  // Default to neutral score if no data
  if (!candidate.remote_work_preference && !job.remote_work_allowed) {
    return 50;
  }

  let score = 50;

  // If job allows remote work
  if (job.remote_work_allowed) {
    switch (candidate.remote_work_preference) {
      case 'full':
        score += 50; // Perfect match for fully remote candidate
        break;
      case 'hybrid':
        score += 40; // Good match for hybrid preference
        break;
      case 'occasional':
        score += 30; // Decent match for occasional remote
        break;
      case 'no':
        score += 10; // Still okay if they prefer in-person but remote is available
        break;
      default:
        score += 25; // No preference specified
    }
  } else {
    // Job doesn't allow remote work
    switch (candidate.remote_work_preference) {
      case 'no':
        score += 50; // Perfect match for in-person preference
        break;
      case 'occasional':
        score += 30; // Okay match
        break;
      case 'hybrid':
        score += 10; // Poor match
        break;
      case 'full':
        score -= 30; // Bad match for fully remote preference
        break;
      default:
        score += 25; // No preference specified
    }
  }

  return Math.min(100, Math.max(0, score));
}
